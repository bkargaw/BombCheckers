{"version":3,"sources":["webpack:///webpack/bootstrap 93177d1a9159a526464c","webpack:///./lib/pieces.js","webpack:///./lib/board.js","webpack:///./lib/bomb_pieces.js","webpack:///./lib/computer_player.js","webpack:///./lib/shield_pieces.js","webpack:///./lib/BombCheckers.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACzFA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,iBAAiB,iBAAiB;AACpD,kBAAkB,iBAAiB,iBAAiB;AACpD,oBAAoB,kBAAkB,kBAAkB;;AAExD;AACA,kBAAkB,iBAAiB,iBAAiB;AACpD,kBAAkB,iBAAiB,iBAAiB;AACpD,kBAAkB,kBAAkB,kBAAkB;;AAEtD;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO;AACP;AACA;;;AAGA;AACA;AACA,sBAAsB,kCAAkC;;;AAGxD;;AAEA;AACA;AACA,oBAAoB,OAAO;AAC3B,sBAAsB,OAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA,sBAAsB,OAAO;AAC7B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC9bA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,WAAW;AAClC,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,6BAA6B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACzFA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;AClCA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,kCAAkC;AAClC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,sBAAsB,OAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,OAAO;AAC5C,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;AAKA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEQ","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 93177d1a9159a526464c","class Piece {\n  constructor(side , board, pos){\n    this.side = side;\n    this.board = board;\n    this.x = pos[0];\n    this.y = pos[1];\n    this.Piecetype = 'pawn';\n    this.isKing = false;\n    this.haskilledthisturn = false;\n    this.kingImage = this.setKingImage();\n    this.pieceImage =  this.setPieceImage();\n  }\n\n  setPos(pos){\n    this.x = pos[0];\n    this.y = pos[1];\n  }\n\n\n  getboard() {\n    return this.board;\n\t}\n\n  setKing(isKing) {\n\t\tthis.isKing = isKing;\n\t}\n\n  setPiecetype(Piecetype) {\n\t\tthis.Piecetype = Piecetype;\n\t}\n\n  side() {\n\t\treturn this.side;\n\t}\n\n\n  getImage(){\n    if (this.isKing){\n      return this.kingImage;\n    }else {\n      return this.pieceImage;\n    }\n  }\n\n  setKingImage(){\n    let kingImage = new Image();\n    if(this.side === 'red'){\n      kingImage.src = './asset/images/pawn-fire-crowned.png';\n    }else{\n      kingImage.src =  './asset/images/pawn-water-crowned.png';\n    }\n    return kingImage;\n  }\n\n  setPieceImage(){\n    let PawnImg =  new Image();\n    if(this.side === 'red'){\n      PawnImg.src = './asset/images/pawn-fire.png';\n    }else{\n      PawnImg.src =  './asset/images/pawn-water.png';\n    }\n    return PawnImg;\n  }\n\n\n\tblowUp(x, y) {\n    if( this.board.pieces[x][y] !== null) {\n      this.board.remove(x,y);\n    }\n\t}\n\n  // only applies to bomb pieces\n  // explode( x, y) {\n  //  }\n\t/**\n\t * Signals that this Piece has begun to capture (as in it captured a Piece)\n\t */\n  startCapturing() {\n\t\tthis.haskilledthisturn = true;\n\t}\n\n\t/**\n\t * Resets the Piece for future turns\n\t */\n  finishCapturing() {\n\t\tthis.haskilledthisturn = false;\n\t}\n}\n\nmodule.exports = Piece;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/pieces.js\n// module id = 0\n// module chunks = 0","const Piece = require('./pieces.js');\nconst BombPiece = require('./bomb_pieces.js');\nconst ShieldPiece = require('./shield_pieces.js');\nconst ComputerPlayer = require('./computer_player.js');\n\nclass Board {\n  constructor(ctx, color1, color2,startAnim, drawFrame,towPlayer) {\n    this.pieces = this.setBoardUp();\n    this.current_player = 'blue';\n    this.current_player_has_moved = false;\n    this.current_player_has_selected = false;\n    this.current_player_piece_pos = [];\n    this.cp = new ComputerPlayer(this);\n    this.ctx = ctx;\n    this.color1 = color1;\n    this.color2 = color2;\n    this.startAnim = startAnim;\n    this.drawFrame = drawFrame;\n    this.towPlayer= towPlayer;\n  }\n\n  makeTowPlayer(){\n    this.towPlayer = !this.towPlayer;\n  }\n\n  resetBackgroundColor(color1, color2){\n    this.color1 = color1;\n    this.color2 = color2;\n  }\n\n  setBoardUp(){\n    let grid = new Array(8);\n    for (let i = 0 ; i< 8 ; i++){\n      grid[i] = new Array(8);\n      for(let j = 0 ; j < 8 ; j++){\n        grid[i][j]= null;\n      }\n    }\n    // red classic\n    let R1 = new Piece('red', this, [0, 0]);\n    let R2 = new Piece('red', this, [2, 0]);\n\t\tlet R3 = new Piece('red', this, [4, 0]);\n    let R4 = new Piece('red', this, [6, 0]);\n\t\t// red Shields\n\t\tlet R5 = new ShieldPiece('red', this, [1, 1]);\n    let R6 = new ShieldPiece('red', this, [3, 1]);\n\t\tlet R7 = new ShieldPiece('red', this, [5, 1]);\n    let R8 = new ShieldPiece('red', this, [7, 1]);\n\t\t// red bomb\n\t\tlet R9 = new BombPiece('red', this, [0, 2]);\n    let R10 = new BombPiece('red', this, [2, 2]);\n\t\tlet R11 = new BombPiece('red', this, [4, 2]);\n    let R12 = new BombPiece('red', this, [6, 2]);\n\n    // blue classic\n\t\tlet B1 = new Piece('blue', this, [7, 7]);\n    let B2 = new Piece('blue', this, [5, 7]);\n    let B3 = new Piece('blue', this, [3, 7]);\n    let B4 = new Piece('blue', this, [1, 7]);\n\t\t// Blue Shields\n\t\tlet B5 = new ShieldPiece('blue', this, [0, 6]);\n    let B6 = new ShieldPiece('blue', this, [2, 6]);\n    let B7 = new ShieldPiece('blue', this, [4, 6]);\n    let B8 = new ShieldPiece('blue', this, [6, 6]);\n\t\t// Blue bomb\n\t\tlet B9 = new BombPiece('blue', this, [7, 5]);\n    let B10 = new BombPiece('blue', this, [5, 5]);\n\t\tlet B11 = new BombPiece('blue', this, [3, 5]);\n    let B12 = new BombPiece('blue', this, [1, 5]);\n\n      // RED SIDE\n\t\tgrid[0][0] = R1; grid[2][0] = R2; grid[4][0] = R3; grid[6][0] = R4;\n\t\tgrid[1][1] = R5; grid[3][1] = R6; grid[5][1] = R7; grid[7][1] = R8;\n    grid[0][2] = R9; grid[2][2] = R10; grid[4][2] = R11; grid[6][2] = R12;\n\n      // BLUE SIDE\n\t\tgrid[7][7] = B1; grid[5][7] = B2; grid[3][7] = B3; grid[1][7] = B4;\n\t\tgrid[0][6] = B5; grid[2][6] = B6; grid[4][6] = B7; grid[6][6] = B8;\n\t\tgrid[7][5] = B9; grid[5][5] = B10; grid[3][5] = B11; grid[1][5] = B12;\n\n    return grid;\n  }\n\n  switchPlayer(){\n    if ( this.current_player === 'blue'){\n      this.current_player = 'red';\n    }else {\n      this.current_player = 'blue';\n    }\n  }\n\n  _isInbound(x, y){\n    if ( x >= 0 && x <= 7  && y >= 0 && y <= 7 ) return true;\n    return false;\n  }\n  /*\n   Gets the piece at position (x, y) on the board, or null if there is no piece.\n   If (x, y) are out of bounds, returns null.\n   */\n  pieceAt( x, y){\n    if (!(this._isInbound(x, y))) return null;\n    return this.pieces[x][y];\n  }\n\n  /* Places p at (x, y). If (x, y) is out of bounds or if p is null, does nothing.\n   If another piece already exists at (x, y), p will replace that piece. (This method is potentially\n   useful for creating specific test circumstances.)\n   */\n   place( piece ,  x,  y){\n     if ( this._isInbound() ) {\n       if (piece !== null){\n         this.pieces[x][y] = piece;\n       }\n     }\n   }\n\n  /*\n  Executes a remove. Returns the piece that was removed.\n  * If the input (x, y) is out of bounds, returns null and prints\n  an appropriate message.\n  * If there is no piece at (x, y), returns null and prints an\n  appropriate message.\n   */\n  remove( x,  y) {\n    if ( !(this._isInbound(x,  y))) return null;\n    let piece = this.pieces[x][y];\n    this.pieces[x][y] = null;\n    return piece;\n  }\n  /*\n   Returns true if the square at (x, y) can be selected.\n  - A square with a piece may be selected if it is the\n    corresponding player’s turn and one of the following is true:\n    * The player has not selected a piece yet.\n    * The player has selected a piece, but did not move it.\n\n  - An empty square may be selected if one of the following is true:\n\n    * During this turn, the player has selected a Piece which hasn’t\n    moved yet and is selecting an empty spot which is a valid move for\n    the previously selected Piece.\n\n    * During this turn, the player has selected a Piece, captured,\n    and has selected another valid capture destination. When performing\n    multi-captures, you should only select the activepiece once; all\n    other selections should be valid destination points.\n  */\n  canSelect(x, y){\n    if (this._isInbound(x,y)){\n      let piece = this.pieces[x][y];\n      if (piece) {\n        //  there is a piece at this location\n          if (!this.current_player_has_selected ||\n             (this.current_player_has_selected &&\n             !this.current_player_has_moved)){\n\n               // can only move your own piece\n             if(piece.side === this.current_player){\n               return true;\n             }\n        }\n      }else{\n        //  there is a NO piece at this location\n        // if the\n        let pos = this.current_player_piece_pos;\n        if(this.current_player_has_selected &&\n           !(this.pieces[pos[0]][pos[1]].haskilledthisturn) &&\n            !(this.current_player_has_moved)){\n            return this.validFirstMove(pos[0], pos[1], x, y);\n        }\n        if(this.current_player_has_selected &&\n           (this.pieces[pos[0]][pos[1]].haskilledthisturn)){\n            return this.validCapturingMove(pos[0], pos[1], x, y);\n        }\n      }\n    }\n    return false;\n  }\n\n  validFirstMove(intx, inty, finx, finy){\n    let deltX = finx - intx;\n    let deltY = finy - inty;\n\n    if(Math.abs(deltX) !== 1 || Math.abs(deltY) !== 1){\n\n      // this means the selected place is an attempt to capture\n      return this.validCapturingMove(intx, inty, finx, finy);\n\n    }else if(Math.abs(deltX) === 1 && Math.abs(deltY) === 1) {\n\n      // this mean the destination is one step only\n      if (intx !== finx && intx !== finy){\n\n        //  this means that the destination is not vert or horz\n        let piece = this.pieces[intx][inty];\n\n        if (piece.isKing){\n          // this means the piece is a king\n          return true;\n        }else{\n\n          if (piece.side === 'red' && deltY === 1) return true;\n          if (piece.side === 'blue' && deltY === -1) return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  validCapturingMove(intx, inty, finx, finy){\n    let deltX = finx - intx;\n    let deltY = finy - inty;\n    if(Math.abs(deltX) === 2 && Math.abs(deltY) === 2){\n      let piece = this.pieces[intx][inty];\n      let xjumped = intx + deltX/2;\n      let yjumped = inty + deltY/2;\n      let killPiece = this.pieces[xjumped][yjumped];\n      if(killPiece && killPiece.side !== this.current_player){\n        if (piece.isKing){\n          // this means the piece is a king\n          return true;\n        }else{\n          if (piece.side === 'red' && deltY === 2) return true;\n          if (piece.side === 'blue' && deltY === -2) return true;\n        }\n      }\n\n    }\n    return false;\n  }\n\n  /*\nSelects the square at (x, y). This method assumes canSelect (x,y) returns true.\n  In respect to the GUI, when you select a Piece, color the background\n  of the selected\n  square white on the GUI via the pen color function. For any piece to\n  perform a capture,\n  that piece must have been selected first. If you select a square with\n  a piece, you are prepping\n  that piece for movement. If you select an empty square (assuming\n  canSelect returns true), you should\n  move your most recently selected piece to that square.\n  */\n\n  select( x, y ){\n    let piece = this.pieces[x][y];\n    if (piece){\n      // there is a piece at that loc... selecting a piece to move\n      this.current_player_has_selected = true;\n    }else{\n      // there is noting at that location and the piece is moveing or capturing\n      let [x1 , y1] = this.current_player_piece_pos;\n      let movetype =this.move( x1,  y1,  x,  y);\n      if (movetype === 'explode' ){\n        this.current_player_piece_pos = [x,y];\n        return true;\n      }\n      // get ready for other capturing\n    }\n    this.current_player_piece_pos = [x,y];\n    return false;\n  }\n\n  /*\n  Assumes Piece p's movement from (x1, y1) to (x2, y2) is valid.\n  Moves the piece at (x1, y1), to (x2, y2) capturing any intermediate\n  piece if applicable.\n  */\n  move( x1,  y1,  x2,  y2){\n    // make the thing a king when y is 7 for red and 0 for blue\n    let piece = this.pieces[x1][y1];\n    if (y2 === 7 && piece.side === 'red'){\n      piece.setKing(true);\n    }else if(y2 === 0 && piece.side === 'blue'){\n      piece.setKing(true);\n\n    }\n    if (Math.abs(x2 - x1) === 2){\n      let xDelete = (x1 + x2) / 2;\n      let yDelete = (y1 + y2) / 2;\n      this.pieces[xDelete][yDelete] = null;\n      this.pieces[x1][y1] = null;\n      this.pieces[x2][y2] = piece;\n      piece.startCapturing();\n      if (piece.Piecetype === 'bomb'){\n        this.pieces[x1][y1] = null;\n        this.pieces[x2][y2] = piece;\n        piece.setPos([x2, y2]);\n        this.current_player_has_moved = true;\n        this.drawBackGround();\n        this.drawThePieces();\n        return 'explode';\n      }\n    }\n    this.pieces[x1][y1] = null;\n    this.pieces[x2][y2] = piece;\n    piece.setPos([x2, y2]);\n    this.current_player_has_moved = true;\n    this.drawBackGround();\n    this.drawThePieces();\n    return null;\n  }\n\n  /*\n  Returns whether or not the the current player can end their turn.\n  To be able to end a turn, a piece must have moved or performed a capture.\n  */\n  canEndTurn(){\n    return this.current_player_has_moved;\n  }\n  /*\n  Called at the end of each turn. Handles switching of players and\n  anything else that should happen at the end of a turn.\n  */\n\n  endTurn() {\n    let [x,y] = this.current_player_piece_pos;\n    this.pieces[x][y].finishCapturing();\n    this.switchPlayer();\n    this.current_player_has_moved = false;\n    this.current_player_has_selected = false;\n    this.current_player_piece_pos = [];\n    if(this.current_player === 'red' && this.current_player_has_selected){\n      this.runComputersTurn();\n    }else{\n      this.upDateCurrentUserInfor();\n    }\n  }\n\n  runComputersTurn(){\n    if (!this.towPlayer){\n      let that = this;\n      let val;\n      setTimeout(function(){\n        val = that.cp.makeMove();\n        if (val){\n          let [x, y] = that.current_player_piece_pos;\n          let bombPiece = that.pieces[x][y];\n          let clearDeadPieces = () => bombPiece.explode(x,y);\n          let moveComputer = () => {};\n          that.startAnim((x * 75) - 90 , (y * 75) - 90,\n          clearDeadPieces, moveComputer);\n          that.endTurn();\n        }\n\n      }, 500);\n    }\n  }\n\n\n  upDateCurrentUserInfor(){\n    document.getElementById('infoToTheUser').innerHTML\n    =`It is <strong>${this.current_player.toUpperCase()}'s</strong> turn,<br/> press space to end turn`;\n\n\n  }\n\n  drawBackGround() {\n    let colors = this._createColorForGrid();\n    for (let i = 0 ; i < 8; i++){\n      for (let j = 0 ; j < 8; j++){\n        let x = i * 75 ;\n        let y = j * 75;\n        this.ctx.beginPath();\n        this.ctx.rect(x, y, 75, 75);\n        this.ctx.fillStyle = colors[i][j];\n        this.ctx.fill();\n      }\n    }\n  }\n\n  _createColorForGrid(){\n    let colorGrid = new Array(8);\n    let fillbox = true;\n    for (let i = 0 ; i < 8; i++) {\n      colorGrid[i] = new Array(8);\n      for (let j = 0 ; j < 8; j++) {\n        if (fillbox){\n          colorGrid[i][j] = this.color1;\n        }else{\n          colorGrid[i][j] = this.color2;\n        }\n        fillbox = !fillbox;\n      }\n      fillbox = !fillbox;\n    }\n    return colorGrid;\n  }\n\n\n\n  drawThePieces(){\n    let piece;\n    let scale = 75;\n    for (let i = 0; i < 8 ; i++){\n      for(let j = 0; j < 8 ; j++){\n        piece = this.pieces[i][j];\n        if( piece ){\n          let scaledX = piece.x;\n          let scaledY = piece.y;\n          let img = piece.getImage();\n          if(img.complete) { //check if image was already loaded by the browser\n            this.drawAPiece(img, piece.x , piece.y, scale);\n          }else {\n            img.onload = ()=> this.drawAPiece(img, scaledX , scaledY, scale);\n          }\n        }\n      }\n    }\n  }\n\n  drawAPiece(baseImage, x , y, scale){\n    this.ctx.drawImage(baseImage, x * scale , y * scale, 75, 75 );\n  }\n\n  /*\n   - Returns the winner of the game: \"Fire\", \"Water\", \"Tie\", or null.\n   If only fire pieces remain on the board, fire wins. If only water\n    pieces remain, water wins. If no pieces remain (consider an explosion\n    capture), no one wins and it is a tie. If the game is still in\n    progress (ie there are pieces from both sides still on the board)\n     return null. Assume there is no stalemate situation in which the\n     current player has pieces but cannot legally move any of them\n     (In this event, just leave it at null). Determine the winner solely\n     by the number of pieces belonging to each team.\n  */\n winner(){\n   let countFire = 0;\n   let countWater = 0;\n   for (let i = 0; i < 8; i++){\n     for (let j = 0; j < 8; j++){\n       let piece = this.pieces[i][j];\n       if(piece){\n         if (piece.side === 'red') countFire++;\n         if (piece.side === 'blue') countWater++;\n        if (countWater > 0 && countFire > 0) return null;\n       }\n     }\n   }\n   if (countWater === 0 && countFire === 0) return 'Tie';\n   if (countWater === 0 && countFire > 0) return 'Fire';\n   if (countWater > 0 && countFire === 0) return 'Water';\n   return null;\n  }\n}\n\nmodule.exports = Board;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/board.js\n// module id = 1\n// module chunks = 0","const Piece = require('./pieces.js');\n\n\nclass BombPiece extends Piece {\n  constructor(side,  board, pos) {\n\t  super(side, board, pos);\n\t  this.setPiecetype('bomb');\n  }\n\n  setKingImage(){\n    let kingImage = new Image();\n    if(this.side === 'red'){\n      kingImage.src = './asset/images/bomb-fire-crowned.png';\n    }else{\n      kingImage.src =  './asset/images/bomb-water-crowned.png';\n    }\n    return kingImage;\n  }\n\n  setPieceImage(){\n    let BombImg =  new Image();\n    if(this.side === 'red'){\n      BombImg.src = './asset/images/bomb-fire.png';\n    }else{\n      BombImg.src =  './asset/images/bomb-water.png';\n    }\n    return BombImg;\n  }\n\n  explode( x, y ) {\n\t\t\t  let xmin= x-1;\n\t\t\t  let ymin= y-1;\n\t\t\t  let xmax= x+1;\n\t\t\t  let ymax= y+1;\n\t\t\t  if (x === 0){\n\t\t\t\t  xmin = x;\n\t\t\t  }\n\t\t\t  if (y === 0){\n\t\t\t\t  ymin = y;\n\t\t\t  }\n\t\t\t  if (x === 7){\n\t\t\t\t  xmax = x;\n\t\t\t\t\t\t  }\n\t\t\t  if (y === 7){\n\t\t\t\t  ymax = y;\n\t\t\t  }\n\t\t\t  for (let i = xmin; i <= xmax; i++){\n\t\t\t\t  for (let j = ymin; j <= ymax; j++){\n\t\t\t\t\t  if (this.board.pieces[i][j] !== null){\n\t\t\t\t\t      this.board.pieces[i][j].blowUp(i,j);\n\t\t\t\t\t  }\n\t\t\t\t  }\n\t\t\t  }\n\t\t}\n}\n  module.exports = BombPiece;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/bomb_pieces.js\n// module id = 2\n// module chunks = 0","class ComputerPlayer {\n  constructor(board, side = 'red') {\n    this.board = board;\n    this.side = side;\n    this.Moves = [];\n    this.myPieces = [];\n    this.optionDelta =[[ 2 , -2], [-2, -2],[ 2 , 2], [-2, 2],\n                       [ 1 , -1], [-1, -1],[ 1 , 1], [-1, 1]];\n  }\n\n  makeMove(){\n    this.SelecePieceToMove();\n    let val = this.findAllMoves();\n    if (val){\n      this.resetValues();\n      return val;\n    }else{\n      if (this.Moves.length >= 2){\n        this.resetValues();\n        this.board.endTurn();\n      }else {\n        this.myPieces.shift();\n        this.Moves = [];\n        this.makeMove();\n      }\n    }\n  }\n\n  SelecePieceToMove(){\n    if (!this.myPieces.length)  this.myPieces = this.getMyPieces();\n    this.myPieces.sort(this.compare);\n    for(let i = 0; i < this.myPieces.length; i++){\n      let x = this.myPieces[i].x;\n      let y = this.myPieces[i].y;\n      if (this.board.canSelect(x, y)){\n        this.Moves.push([x,y]);\n        this.board.select(x,y);\n        break;\n      }else{\n        this.myPieces.shift();\n      }\n    }\n  }\n\n  findAllMoves(){\n    let numMoves = this.Moves.length - 1;\n    for (let i = 0 ; i < this.optionDelta.length; i++){\n      let x = this.Moves[numMoves][0] + this.optionDelta[i][0];\n      let y = this.Moves[numMoves][1] + this.optionDelta[i][1];\n      if (this.board.canSelect(x, y)\n          && this.board.pieces[x]\n          && this.board.pieces[x][y] === null){\n        this.board.select(x,y);\n        this.Moves.push([x,y]);\n        let piece = this.board.pieces[x][y];\n        if (piece.Piecetype === 'bomb' && piece.haskilledthisturn){\n          return 'explode';\n        }\n      }\n    }\n  }\n\n  getMyPieces(){\n    let myPieces = [];\n    for(let i = 0; i < 8; i++ ){\n      for(let j = 0; j < 8; j++){\n        let piece = this.board.pieces[i][j];\n        if (piece && piece.side === this.side) myPieces.push(piece);\n      }\n    }\n    return myPieces;\n  }\n\n  compare(a, b) {\n   if (a.y > b.y) {\n     return -1;\n   }\n   if (a.y < b.y) {\n     return 1;\n   }\n   return 0;\n }\n\n  resetValues(){\n    this.Moves = [];\n    this.myPieces = [];\n  }\n}\n\nmodule.exports = ComputerPlayer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/computer_player.js\n// module id = 3\n// module chunks = 0","const Piece = require('./pieces.js');\n\nclass ShieldPiece extends Piece {\n  constructor( side, board, pos){\n\t  super(side, board, pos);\n\t  this.setPiecetype('shield');\n  }\n\n  setKingImage(){\n    let kingImage = new Image();\n    if(this.side === 'red'){\n      kingImage.src = './asset/images/shield-fire-crowned.png';\n    }else{\n      kingImage.src =  './asset/images/shield-water-crowned.png';\n    }\n    return kingImage;\n  }\n\n  setPieceImage(){\n    let WaterImg =  new Image();\n    if(this.side === 'red'){\n      WaterImg.src = './asset/images/shield-fire.png';\n    }else{\n      WaterImg.src =  './asset/images/shield-water.png';\n    }\n    return WaterImg;\n  }\n\n  blowUp(x, y) {\n    // does not blow up!!!\n\t}\n\n}\n\nmodule.exports = ShieldPiece;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/shield_pieces.js\n// module id = 4\n// module chunks = 0","const Board = require('./board.js');\n\nlet c;\nlet color1;\nlet color2;\nlet ctx;\nlet board;\nlet cBackGround1;\nlet cBackGround1Ctx1;\n\nlet cBackGround2;\nlet cBackGround2Ctx2;\n\nlet cBackGroundOriginal;\nlet cBackGroundOriginalCtx;\n\nlet highlightColor = 'white';\n\nlet towPlayer = false;\n\nlet explosionSprite = new Image();\nexplosionSprite.src = 'asset/images/explosion-sprite-sheet.png';\nvar explosionSound = new Audio(\"asset/audio/Bomb_Exploding.mp3\");\nvar music = new Audio(\"asset/audio/music.mp3\");\nvar stopExplosion = false;\n\n// below this is the logic for the explosion rendering\n\nvar Xs = 0;\nvar Ys = 0;\nvar w = 240;\nvar h = 240;\nvar frameCnt = 25;\nvar idx = 0;\nvar intval;\nfunction startAnim(locx, locy, clearDeadPieces, moveComputer) {\n  drawBackGround();\n  drawThePieces();\n  if(!stopExplosion) explosionSound.play();\n\tclearInterval(intval);\n\tXs = 0;\n\tYs = 0;\n\tidx= 0;\nintval = setInterval(function(){drawFrame(locx, locy,\n  clearDeadPieces, moveComputer);},60);\n}\n\nfunction pleaseStopExplosion() {\n  stopExplosion = !stopExplosion;\n}\n\nfunction pleaseStopmusic() {\n  if (!music.paused){\n    music.pause();\n  }else {\n    music.play();\n  }\n}\n\nfunction drawFrame(locx, locy, clearDeadPieces,moveComputer) {\n\tctx.drawImage(explosionSprite, Xs, Ys , 64, 64, locx, locy, w, h);\n\tXs += 64;\n\tidx++;\n\tif(idx % 5 === 0) {\n\t\tXs = 0;\n\t\tYs += 64;\n\t}\n\tif(idx > frameCnt){\n    clearInterval(intval);\n    clearDeadPieces();\n    drawBackGround();\n    drawThePieces();\n    moveComputer();\n  }\n}\n\n$( ()=>{\n  c = document.getElementById(\"canvas\");\n  c.width  = 600;\n  c.height = 600;\n  ctx = c.getContext(\"2d\");\n\n\n  //default board colors\n  color1 = 'gray';\n  color2 = 'red';\n  board = new Board(ctx, color1, color2, startAnim, drawFrame, towPlayer);\n\n  // background option canvas 2\n  cBackGround2 = document.getElementById(\"background2\");\n  cBackGround2.width  = 100;\n  cBackGround2.height = 100;\n  cBackGround2Ctx2 = cBackGround2.getContext(\"2d\");\n  cBackGround2.addEventListener('click',\n        ChengeBackgroundColor('rgb(249, 189, 129)', 'rgb(255, 55, 0)'));\n\n  // background option canvas 1\n  cBackGround1 = document.getElementById(\"background1\");\n  cBackGround1.width  = 100;\n  cBackGround1.height = 100;\n  cBackGround1Ctx1 = cBackGround1.getContext(\"2d\");\n  cBackGround1.addEventListener('click',\n        ChengeBackgroundColor('rgb(68, 62, 62)', 'white'));\n\n  // background option canvas original\n  cBackGroundOriginal = document.getElementById(\"backgroundOrignal\");\n  cBackGroundOriginal.width  = 100;\n  cBackGroundOriginal.height = 100;\n  cBackGroundOriginalCtx = cBackGroundOriginal.getContext(\"2d\");\n  cBackGroundOriginal.addEventListener('click',\n        ChengeBackgroundColor('rgb(173, 168, 168)', 'red'));\n  draw();\n  c.addEventListener('click', handleClickFromUser);\n  document.body.onkeyup = function(e){\n    if(e.keyCode === 32 || e.keyCode === 13) endTurn();\n  };\n  let reset = document.getElementById(\"resetGame\");\n  reset.addEventListener('click', resetGame);\n  drawTheBackgroundOptions();\n\n  let stopbomb = document.getElementById(\"StopBombAduio\");\n  stopbomb.addEventListener('click', pleaseStopExplosion);\n\n  let stopMusic = document.getElementById(\"StopMusic\");\n  stopMusic.addEventListener('click', pleaseStopmusic);\n\n  let makeToPlayer = document.getElementById(\"twoplayerMode\");\n  makeToPlayer.addEventListener('click', ()=> board.makeTowPlayer());\n  drawTheBackgroundOptions();\n  board.upDateCurrentUserInfor();\n});\n\nfunction resetGame() {\n  board = new Board(ctx, color1, color2);\n  drawBackGround();\n  drawThePieces();\n}\n\nfunction ChengeBackgroundColor(col1, col2){\n  return () => {\n    if(col1 === 'rgb(68, 62, 62)'){\n      // change highlighter if the board is black and white\n      highlightColor = 'rgb(210, 103, 224)';\n    }else {\n        highlightColor = 'white';\n    }\n    color1 = col1;\n    color2 = col2;\n    board.resetBackgroundColor(color1, color2);\n    drawBackGround();\n    drawThePieces();\n  };\n\n}\n\n\n  function draw() {\n    drawBackGround();\n    drawThePieces();\n  }\n\n  function drawTheBackgroundOptions() {\n    let background1Image = new Image();\n    background1Image.onload = ()=> cBackGround1Ctx1.drawImage(\n      background1Image, 0, 0, 100, 100);\n    background1Image.src = 'asset/images/white & black.png';\n\n    let background2Image = new Image();\n    background2Image.onload = ()=> cBackGround2Ctx2.drawImage(\n      background2Image, 0, 0, 100, 100);\n    background2Image.src = 'asset/images/wood.png';\n\n    let backgroundOriginalImage = new Image();\n    backgroundOriginalImage.onload = ()=> cBackGroundOriginalCtx.drawImage(\n      backgroundOriginalImage, 0, 0, 100, 100);\n    backgroundOriginalImage.src = 'asset/images/red and gray.png';\n  }\n\n  function drawBackGround() {\n    ctx.clearRect(0,0,c.width, c.height);\n    let colors = _createColorForGrid();\n    for (let i = 0 ; i < 8; i++){\n      for (let j = 0 ; j < 8; j++){\n        let x = i * 75 ;\n        let y = j * 75;\n        ctx.beginPath();\n        ctx.rect(x, y, 75, 75);\n        ctx.fillStyle = colors[i][j];\n        ctx.fill();\n      }\n    }\n  }\n\n  function drawThePieces(){\n    let piece;\n    let scale = 75;\n    for (let i = 0; i < 8 ; i++){\n      for(let j = 0; j < 8 ; j++){\n        piece = board.pieces[i][j];\n        if( piece ){\n          let scaledX = piece.x;\n          let scaledY = piece.y;\n          let img = piece.getImage();\n          if(img.complete) { //check if image was already loaded by the browser\n            drawAPiece(img, piece.x , piece.y, scale);\n          }else {\n            img.onload = ()=> drawAPiece(img, scaledX , scaledY, scale);\n          }\n        }\n      }\n    }\n  }\n\nfunction highlightPos(i, j){\n  let x = i * 75 ;\n  let y = j * 75;\n  ctx.beginPath();\n  ctx.rect(x, y, 75, 75);\n  ctx.fillStyle = highlightColor;\n  ctx.fill();\n}\n\nfunction drawAPiece(baseImage, x , y, scale){\n  ctx.drawImage(baseImage, x * scale , y * scale, 75, 75 );\n}\n\nfunction _createColorForGrid(){\n  let colorGrid = new Array(8);\n  let fillbox = true;\n  for (let i = 0 ; i < 8; i++) {\n    colorGrid[i] = new Array(8);\n    for (let j = 0 ; j < 8; j++) {\n      if (fillbox){\n        colorGrid[i][j] = color1;\n      }else{\n        colorGrid[i][j] = color2;\n      }\n      fillbox = !fillbox;\n    }\n    fillbox = !fillbox;\n  }\n  return colorGrid;\n}\n\nfunction _isInbound(x, y){\n  if ( x >= 0 && x <= 7  && y >= 0 && y <= 7 ) return true;\n  return false;\n}\n\nfunction handleClickFromUser(event){\n  let x = Math.floor(event.layerX / 75);\n  let y = Math.floor(event.layerY / 75);\n  if (_isInbound(x,y)){\n    if(board.canSelect(x,y)){\n      if (board.select(x,y)){\n        let bombPiece = board.pieces[x][y];\n        board.endTurn();\n        let clearDeadPieces = () => bombPiece.explode(x,y);\n        let moveComputer = () => board.runComputersTurn();\n        startAnim((x * 75) - 90 , (y * 75) - 90, clearDeadPieces, moveComputer);\n      }else {\n        drawBackGround();\n        highlightPos(x, y);\n        drawThePieces();\n      }\n\n    }else {\n      tellUserError('Invalid move',200,300);\n    }\n  }\n}\n\nfunction endTurn(){\n  if (board.canEndTurn()){\n    let winner = board.winner();\n    if (winner){\n      // add a dialog on the page that tells the user the game is over\n      ctx.font = \"30px Arial\";\n      tellUserError(`the winner is ${winner}`,150, 300,10000);\n    }else{\n      board.endTurn();\n      drawBackGround();\n      drawThePieces();\n      board.runComputersTurn();\n\n    }\n  }else{\n    tellUserError('Please make a move first',140,300);\n  }\n}\n\nfunction tellUserError(msg ,x, y, time = 1000) {\n  var gradient=ctx.createLinearGradient(0,0,c.width,0);\n  gradient.addColorStop(\"0\",\"purple\");\n  gradient.addColorStop(\"0.5\",\"black\");\n  gradient.addColorStop(\"1.0\",\"purple\");\n\n  ctx.font = \"30px Arial\";\n  ctx.fillStyle=gradient;\n  ctx.fillText(msg,x,y);\n  setTimeout(function(){\n    drawBackGround();\n    drawThePieces();\n  }, time);\n}\n\n\n\n\n// create modal containt\n// Get the modal\nvar modal = document.getElementById('myModal');\n\n// Get the button that opens the modal\nvar btn = document.getElementById(\"myBtn\");\n\n// Get the <span> element that closes the modal\nvar span = document.getElementsByClassName(\"close\")[0];\n\n// When the user clicks the button, open the modal\nbtn.onclick = function() {\n    modal.style.display = \"block\";\n};\n\n// When the user clicks on <span> (x), close the modal\nspan.onclick = function() {\n    modal.style.display = \"none\";\n};\n\n// When the user clicks anywhere outside of the modal, close it\nwindow.onclick = function(event) {\n    if (event.target == modal) {\n        modal.style.display = \"none\";\n    }\n};\n\nexport {drawBackGround};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/BombCheckers.js\n// module id = 5\n// module chunks = 0"],"sourceRoot":""}